一、代码优化

1、禁止使用递归；原因：每次递归调用时会向栈中push当前方法的运行状态（现场），而Java栈内存的使用超过限制的大小时，程序会出现栈异常。
2、避免层级嵌套循环。
3、注意方法、类文件中的代码量，适度分离。
4、使用基本类型定义变量时，千万注意该变量值可能为null的情况，此时建议使用对应的包装类来定义变量。
5、避免在同一接口中过多的访问数据库，建议次数控制在3次以内。
6、避免过多使用static变量；原因：静态变量和类的生命周期同步。
7、尽量采用lazy loading的策略，即在需要的时候才开始创建变量和对象等。
8、将一些需要变动的配置或文案写在属性文件中。
9、后端接口需要提供必要的校验，不要过于依赖前端校验。
10、提倡异常封装，提高代码可读性和可维护性等。
11、避免使用硬编码，多使用final定义常变量，提高可读性。
12、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销。
13、除非需要在循环中进行特殊的捕获处理，否则禁止在循环内部使用try…catch…语句。正确的做法是在for循环外部进行异常捕获处理。
14、循环内不要不断创建对象引用。
15、尽量在合适的场合使用单例
 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：
    （1）控制资源的使用，通过线程同步来控制资源的并发访问
    （2）控制实例的产生，以达到节约资源的目的
    （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信
  

16、慎用异常
        异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。
17、在变与不变的过程中，我发现——访问权限控制真的太重要了。在写代码的过程中，我们需要尽量遵循这样一个原则——除了那些必须public的方法，尽量把其他方法定义为private。这样做的好处是，在重构private方法的时候不必再担惊受怕，因为它们不会被类外部访问到，而不必担心有没有对外界造成干扰。


二、数据库优化
1、尽量使用简单的SQL，避免多表查询以及在SQL中处理复杂的逻辑。  
2、尽量将多条SQL语句压缩到一句SQL中
   每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程 
   是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。
3、查询时避免全表扫描，适度增加索引。
4、每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。
5、在查询时不要对所查询列使用函数或者运算，否则索引无法使用到。
6、尽量使用GROUP BY替换DISTINCT。
7、JOIN时使用小结果集驱动大结果集。
8、考虑使用“临时表”暂存中间结果
   简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。 
   但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。
9、模糊查询(LIKE)时避免在关键词前使用”%”（如：LIKE '%小分期'），否则查询必然是全表扫描。
10、对查询进行优化，应尽量避免全表扫描，首先应考虑在where 及 order by涉及的列上建立索引。
11、应尽量避免在 where 子句中使用!=或<>操作符、函数操作、表达式（如：num/2）以及null值判断，否则将引擎放弃使用索引而进行全表扫描。
12、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 
        select id from t where num=10 or num=20 
        可以这样查询： 
        select id from t where num=10 
        union all 
        select id from t where num=20
        in 、 not in 、or 也要慎用，否则条件超过一定数量会导致索引失效(特别注意：严格禁止in后面使用子查询)，如： 
        select id from t where num in(1,2,3) 
        对于连续的数值，能用 between 就不要用 in 了： 
        select id from t where num between 1 and 3
13、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引。14、一个表的索引数最好不要超过6个。
15、任何地方都要慎重使用 select * from t取出所有列 ，不要返回用不到的任何字段。
16、适当将复杂查询切分为若干个单表查询或简易查询。如将关联查询分解为若干个单表查询。
17、老老实实按照规范写SQL，比如字符串一律该加引号就加引号。WHERE username = 1380000000和WHERE username = '1380000000'是不同的。后者能正确使用索引，前者不能。
18、数据库表有version字段的，应当强制不为空。因为baseDao每次更新记录都会在这个字段加1，为空的话会出现异常。
19、SQL语句较长时建议采用Provider拼接，拼接查询Sql时加上” where 1 = 1 “。
20、避免在WHERE 语句中对索引字段进行计算、类型转换等操作，导致索引完全没发挥作用。
21、使用预编译查询
    程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。
22、调整Where字句中的连接顺序
    DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以 
    过滤掉最大数量记录。
23、使用表的别名
    当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减 
    少哪些友列名歧义引起的语法错误。

24、只在必要的情况下才使用事务begin translation
    SQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认commit的。其实，这就是begin tran的一个最小化的形式，好比在每句语句开头隐含了一个begin tran，结束时隐含了一个commit。 
    有些情况下，我们需要显式声明begin tran，比如做“插、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。begin tran 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起commit。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。 
    可见，如果Begin tran套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成block很多。 
    Begin tran使用的原则是，在保证数据一致性的前提下，begin tran 套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用begin tran。
25、用varchar/nvarchar 代替 char/nchar
    尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些 
    不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。
26、更新Update语句优化
    如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志
27、除了掌握SQL基本的优化手段，使用慢日志定位到具体问题SQL，使用explain、profile等工具来逐步调优。


三、缓存优化
分类
a、本地缓存（HashMap/ConcurrentHashMap、Ehcache、RocksDB、Guava Cache等）。
b、缓存服务（Redis/Tair/Memcache等）。

1、什么时候更新缓存？如何保障更新的可靠性和实时性？

更新缓存的策略，需要具体问题具体分析。基本的更新策略有两个：

    1）  接收变更的消息，准实时更新。

    2）  给每一个缓存数据设置5分钟的过期时间，过期后从DB加载再回设到DB。这个策略是对第一个策略的有力补充，解决了手动变更DB不发消息、接收消息更新程序临时出错等问题导致的第一个策略失效的问题。通过这种双保险机制，有效地保证了缓存数据的可靠性和实时性。

2、缓存是否会满，缓存满了怎么办？

对于一个缓存服务，理论上来说，随着缓存数据的日益增多，在容量有限的情况下，缓存肯定有一天会满的。如何应对？

    1）  给缓存服务，选择合适的缓存逐出算法，比如最常见的LRU。

    2）  针对当前设置的容量，设置适当的警戒值，比如10G的缓存，当缓存数据达到8G的时候，就开始发出报警，提前排查问题或者扩容。

    3）  给一些没有必要长期保存的key，尽量设置过期时间。

3、缓存是否允许丢失？丢失了怎么办？

根据业务场景判断，是否允许丢失。如果不允许，就需要带持久化功能的缓存服务来支持，比如Redis或者Tair。更细节的话，可以根据业务对丢失时间的容忍度，还可以选择更具体的持久化策略，比如Redis的RDB或者AOF。

缓存问题
1、缓存穿透

       描述：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

      解决方案：

            1）  接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；

            2）  从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。

2、缓存击穿

      描述：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
3、缓存雪崩

      描述：缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿是并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

     解决方案：

            1）缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。

            2）如果缓存系统是分布式部署，将热点数据均匀分布在不同的缓存节点中。

            3）设置热点数据永远不过期。

4、缓存更新

         Cache Aside 模式：这是最常用最常用的pattern了。其具体逻辑如下：

失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。

命中：应用程序从cache中取数据，取到后返回。

更新：先把数据存到数据库中，成功后，再让缓存失效。

四、JVM优化

后端语言是JAVA，对JVM进行优化也能一定程度上的提升JAVA程序的性能。JVM通常能够在软件开发后期进行，如在开发完毕或者是软件开发的某一里程碑阶段，JVM的各项參数将会直接影响JAVA程序的性能。

性能指标
关注以下指标：CPU使用率、CPU load、GC count、GC time、GC日志

         查看java进程GC状态：jstat -gcutil {pid} 1000

         查看java进程CPU高原因：

        1）  获取java进程pid：ps –ef|grep java

        2）  分析是哪个线程占用率过高：top -H -p ‘PID’

        3）  线程id转换为16进制：printf "%x\n" ‘NID’

        4）  Jstack查看线程堆栈：jstack PID | grep 'NID' -C行数 –color

推荐2个java工具：1）show-busy-java-threads 2）arthas

优化方向
比如，JVM的堆大小（Xms、Xmx），垃圾回收策略等。要进行JVM层面的调优，需要对JVM的执行原理有一定的了解，如内存的结构，GC的种类等，然后根据应用程序的特点设置合理的JVM參数，但是GC tuning is the last task to be done.

五、日志输出优化
我们的应用系统有两种类型日志：
a、用户登录等重要事件的操作日志，存在数据库操作日志表中
b、系统运行时通过Logger打印到文件的运行日志

第一种日志在压测时严重影响性能甚至造成系统崩溃。其实不仅仅是日志，因为数据库的锁机制，只要是高并发地往同一张表写入数据，性能都会急剧下降甚至报错。此时需要引入缓存：先把要写入的数据缓存起来，然后用一个后台工作线程定时或定量触发方式把缓存数据通过Batch SQL的方式批量写入数据库。缓存可以起到削峰的作用，缺点是写入滞后、异常情况下丢失数据。对本系统的日志而言，这些问题可以接受。如果需要高实时性、高可靠性，那就考虑使用Redis、ElasticSearch之类的外部组件，优化架构吧。

第二种日志，如果用户一个动作产生2行日志，并发1000就意味着每秒钟要写入2000行文件，说大不大说小不小，毕竟存储设备也是有IOPS上限的。为了榨取最大性能，可以考虑把日志级别调到WARN以上，减少日志输出量。
一、代码优化

1、禁止使用递归；原因：每次递归调用时会向栈中push当前方法的运行状态（现场），而Java栈内存的使用超过限制的大小时，程序会出现栈异常。
2、避免层级嵌套循环。
3、注意方法、类文件中的代码量，适度分离。
4、使用基本类型定义变量时，千万注意该变量值可能为null的情况，此时建议使用对应的包装类来定义变量。
5、避免在同一接口中过多的访问数据库，建议次数控制在3次以内。
6、避免过多使用static变量；原因：静态变量和类的生命周期同步。
7、尽量采用lazy loading的策略，即在需要的时候才开始创建变量和对象等。
8、将一些需要变动的配置或文案写在属性文件中。
9、后端接口需要提供必要的校验，不要过于依赖前端校验。
10、提倡异常封装，提高代码可读性和可维护性等。
11、避免使用硬编码，多使用final定义常变量，提高可读性。
12、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销。
13、除非需要在循环中进行特殊的捕获处理，否则禁止在循环内部使用try…catch…语句。正确的做法是在for循环外部进行异常捕获处理。
14、循环内不要不断创建对象引用。
15、尽量在合适的场合使用单例
 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：
    （1）控制资源的使用，通过线程同步来控制资源的并发访问
    （2）控制实例的产生，以达到节约资源的目的
    （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信
  

16、慎用异常
        异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。
17、在变与不变的过程中，我发现——访问权限控制真的太重要了。在写代码的过程中，我们需要尽量遵循这样一个原则——除了那些必须public的方法，尽量把其他方法定义为private。这样做的好处是，在重构private方法的时候不必再担惊受怕，因为它们不会被类外部访问到，而不必担心有没有对外界造成干扰。


二、数据库优化
1、尽量使用简单的SQL，避免多表查询以及在SQL中处理复杂的逻辑。
2、尽量将多条SQL语句压缩到一句SQL中
   每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程 
   是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。
3、查询时避免全表扫描，适度增加索引。
4、每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。
5、在查询时不要对所查询列使用函数或者运算，否则索引无法使用到。
6、尽量使用GROUP BY替换DISTINCT。
7、JOIN时使用小结果集驱动大结果集。
8、考虑使用“临时表”暂存中间结果
   简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。 
   但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。
9、模糊查询(LIKE)时避免在关键词前使用”%”（如：LIKE '%小分期'），否则查询必然是全表扫描。
10、对查询进行优化，应尽量避免全表扫描，首先应考虑在where 及 order by涉及的列上建立索引。
11、应尽量避免在 where 子句中使用!=或<>操作符、函数操作、表达式（如：num/2）以及null值判断，否则将引擎放弃使用索引而进行全表扫描。
12、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 
        select id from t where num=10 or num=20 
        可以这样查询： 
        select id from t where num=10 
        union all 
        select id from t where num=20
        in 、 not in 、or 也要慎用，否则条件超过一定数量会导致索引失效(特别注意：严格禁止in后面使用子查询)，如： 
        select id from t where num in(1,2,3) 
        对于连续的数值，能用 between 就不要用 in 了： 
        select id from t where num between 1 and 3
13、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引。14、一个表的索引数最好不要超过6个。
15、任何地方都要慎重使用 select * from t取出所有列 ，不要返回用不到的任何字段。
16、适当将复杂查询切分为若干个单表查询或简易查询。如将关联查询分解为若干个单表查询。
17、老老实实按照规范写SQL，比如字符串一律该加引号就加引号。WHERE username = 1380000000和WHERE username = '1380000000'是不同的。后者能正确使用索引，前者不能。
18、数据库表有version字段的，应当强制不为空。因为baseDao每次更新记录都会在这个字段加1，为空的话会出现异常。
19、SQL语句较长时建议采用Provider拼接，拼接查询Sql时加上” where 1 = 1 “。
20、避免在WHERE 语句中对索引字段进行计算、类型转换等操作，导致索引完全没发挥作用。
21、使用预编译查询
    程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。
22、调整Where字句中的连接顺序
    DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以 
    过滤掉最大数量记录。
23、使用表的别名
    当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减 
    少哪些友列名歧义引起的语法错误。

24、只在必要的情况下才使用事务begin translation
    SQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认commit的。其实，这就是begin tran的一个最小化的形式，好比在每句语句开头隐含了一个begin tran，结束时隐含了一个commit。 
    有些情况下，我们需要显式声明begin tran，比如做“插、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。begin tran 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起commit。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。 
    可见，如果Begin tran套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成block很多。 
    Begin tran使用的原则是，在保证数据一致性的前提下，begin tran 套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用begin tran。
25、用varchar/nvarchar 代替 char/nchar
    尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些 
    不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。
26、更新Update语句优化
    如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志
27、除了掌握SQL基本的优化手段，使用慢日志定位到具体问题SQL，使用explain、profile等工具来逐步调优。


三、缓存优化
分类
a、本地缓存（HashMap/ConcurrentHashMap、Ehcache、RocksDB、Guava Cache等）。
b、缓存服务（Redis/Tair/Memcache等）。

1、什么时候更新缓存？如何保障更新的可靠性和实时性？

更新缓存的策略，需要具体问题具体分析。基本的更新策略有两个：

    1）  接收变更的消息，准实时更新。

    2）  给每一个缓存数据设置5分钟的过期时间，过期后从DB加载再回设到DB。这个策略是对第一个策略的有力补充，解决了手动变更DB不发消息、接收消息更新程序临时出错等问题导致的第一个策略失效的问题。通过这种双保险机制，有效地保证了缓存数据的可靠性和实时性。

2、缓存是否会满，缓存满了怎么办？

对于一个缓存服务，理论上来说，随着缓存数据的日益增多，在容量有限的情况下，缓存肯定有一天会满的。如何应对？

    1）  给缓存服务，选择合适的缓存逐出算法，比如最常见的LRU。

    2）  针对当前设置的容量，设置适当的警戒值，比如10G的缓存，当缓存数据达到8G的时候，就开始发出报警，提前排查问题或者扩容。

    3）  给一些没有必要长期保存的key，尽量设置过期时间。

3、缓存是否允许丢失？丢失了怎么办？

根据业务场景判断，是否允许丢失。如果不允许，就需要带持久化功能的缓存服务来支持，比如Redis或者Tair。更细节的话，可以根据业务对丢失时间的容忍度，还可以选择更具体的持久化策略，比如Redis的RDB或者AOF。

缓存问题
1、缓存穿透

       描述：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

      解决方案：

            1）  接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；

            2）  从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。

2、缓存击穿

      描述：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
3、缓存雪崩

      描述：缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿是并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

     解决方案：

            1）缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。

            2）如果缓存系统是分布式部署，将热点数据均匀分布在不同的缓存节点中。

            3）设置热点数据永远不过期。

4、缓存更新

         Cache Aside 模式：这是最常用最常用的pattern了。其具体逻辑如下：

失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。

命中：应用程序从cache中取数据，取到后返回。

更新：先把数据存到数据库中，成功后，再让缓存失效。

四、JVM优化

后端语言是JAVA，对JVM进行优化也能一定程度上的提升JAVA程序的性能。JVM通常能够在软件开发后期进行，如在开发完毕或者是软件开发的某一里程碑阶段，JVM的各项參数将会直接影响JAVA程序的性能。

性能指标
关注以下指标：CPU使用率、CPU load、GC count、GC time、GC日志

         查看java进程GC状态：jstat -gcutil {pid} 1000

         查看java进程CPU高原因：

        1）  获取java进程pid：ps –ef|grep java

        2）  分析是哪个线程占用率过高：top -H -p ‘PID’

        3）  线程id转换为16进制：printf "%x\n" ‘NID’

        4）  Jstack查看线程堆栈：jstack PID | grep 'NID' -C行数 –color

推荐2个java工具：1）show-busy-java-threads 2）arthas

优化方向
比如，JVM的堆大小（Xms、Xmx），垃圾回收策略等。要进行JVM层面的调优，需要对JVM的执行原理有一定的了解，如内存的结构，GC的种类等，然后根据应用程序的特点设置合理的JVM參数，但是GC tuning is the last task to be done.

五、日志输出优化
我们的应用系统有两种类型日志：
a、用户登录等重要事件的操作日志，存在数据库操作日志表中
b、系统运行时通过Logger打印到文件的运行日志

第一种日志在压测时严重影响性能甚至造成系统崩溃。其实不仅仅是日志，因为数据库的锁机制，只要是高并发地往同一张表写入数据，性能都会急剧下降甚至报错。此时需要引入缓存：先把要写入的数据缓存起来，然后用一个后台工作线程定时或定量触发方式把缓存数据通过Batch SQL的方式批量写入数据库。缓存可以起到削峰的作用，缺点是写入滞后、异常情况下丢失数据。对本系统的日志而言，这些问题可以接受。如果需要高实时性、高可靠性，那就考虑使用Redis、ElasticSearch之类的外部组件，优化架构吧。

第二种日志，如果用户一个动作产生2行日志，并发1000就意味着每秒钟要写入2000行文件，说大不大说小不小，毕竟存储设备也是有IOPS上限的。为了榨取最大性能，可以考虑把日志级别调到WARN以上，减少日志输出量。
